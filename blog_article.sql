/*
 Navicat Premium Data Transfer

 Source Server         : blog
 Source Server Type    : SQLite
 Source Server Version : 3017000
 Source Schema         : main

 Target Server Type    : SQLite
 Target Server Version : 3017000
 File Encoding         : 65001

 Date: 11/07/2020 22:56:14
*/

PRAGMA foreign_keys = false;

-- ----------------------------
-- Table structure for blog_article
-- ----------------------------
DROP TABLE IF EXISTS "blog_article";
CREATE TABLE "blog_article" (
  "article_id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
  "title" text NOT NULL,
  "brief_content" text NOT NULL,
  "content" text NOT NULL,
  "date" datetime NOT NULL
);

-- ----------------------------
-- Records of "blog_article"
-- ----------------------------
INSERT INTO "blog_article" VALUES (1, 'Spark简介 --大数据', '一、Spark是什么？ 快速且通用的集群计算平台 二、Spark的特点： 1. 快速：Spark扩充流行的Mapreduce计算模型，是基于内存的计算 2. 通用：Spark的设计容纳了其它分布式系统拥有的功能，批处理、迭代式计算、交互查询和流处理等，降低了维护成本', '一、Spark是什么？
快速且通用的集群计算平台

二、Spark的特点：
快速：Spark扩充流行的Mapreduce计算模型，是基于内存的计算
通用：Spark的设计容纳了其它分布式系统拥有的功能，批处理、迭代式计算、交互查询和流处理等，降低了维护成本
高度开放：Spark提供Python、Java、Scala、SQL的API和丰富的内置库，Spark和其它的大数据工作整合得很好，包括hadoop、Kafka
三、Spark的组件
1、Spark Core
包含基本功能，包括任务调度、内存管理、容错机制。内部定义了RDDS（弹性分布式数据集），提供了很多APIs来创建和操作这些RDDs。
应用场景：为其它组件提供底层的服务。

2、Spark SQL
Spark处理结构化数据的库，像Hive SQL、MySQL一样。
应用场景：企业中用来做报表统计

3、Spark Streaming
实时数据流处理组件，类似Storm。Spark Streaming提供API来操作实时流数据。
应用场景：企业中用来从Kafka接收数据做实时统计

4、MLlib
一个包含通用机器学习功能的包，Machine learning lib。包含分类、聚类、回归等，还包括模型评估和数据导入。MLlib提供的上面这些方法，都支持集群上的横向扩展。

5、Graphx
处理图的库（例如社交网络图），并进行图的并行计算，像Spark Streaming,Spark SQL一样，它继承了RDD API。提供了各种图的操作，和常用的图算法，例如RangeRank算法
应用场景：图计算

6、Cluster Manager
集群管理，Spark自带一个集群管理是单独调度器。常见的集群管理包括：Hadoop YARN、Apache Mesos

四、紧密集成的优点
Spark底层优化，基于Spark底层的组件，也得到相应的优化。紧密集成，节省了各个组件使用时的部署，测试时间。向Spark增加新的组件时，其它组件可立即享用新组件的功能。

五、Spark和Hadoop比较
Hadoop应用场景：离线处理、对及时性要求不高
Spark应用场景：时效性要求高、机器学习等领域', '2019-05-10 05:18:29.745317');
INSERT INTO "blog_article" VALUES (2, '关系型与非关系型数据库 --数据库技术', '1、关系型数据库 特点： 数据与数据之间、表和字段之间，表和表之间存在关系等 代表： MySQL、Oracle等 优点： 1. 数据之间存在关系，数据的增删改查非常方便 2. 关系型数据库有事务操作，保证数据的完整性 缺点： 1. 数据和数据之间有关系，是由底层大量算法保证，大量算法会拉低系统运行速', '1、关系型数据库
特点：
数据与数据之间、表和字段之间，表和表之间存在关系等

代表：
MySQL、Oracle等

优点：
数据之间存在关系，数据的增删改查非常方便
关系型数据库有事务操作，保证数据的完整性
缺点：
数据和数据之间有关系，是由底层大量算法保证，大量算法会拉低系统运行速度、大量算法会消耗系统资源
海量数据的增删改查时会显得无能为力，很可能宕机
海量数据环境下对数据表进行维护，也会变得无能为力，数据维护和结构维护很难成功
适用：
适合处理一般量级的数据，并且对数据安全性有一定要求

2、非关系型数据库（NoSQL:not only sql）
特点：
处理海量数据，需要将关系型数据库的关系去掉，非关系型数据库设计的初衷是为了替代关系型数据库

代表：
Redis、MongoDB(淘汰)等

优点：
海量数据的增删改查，能够轻松应对
海量数据维护非常轻松
缺点：
数据和数据之间没有关系，所以不能一目了然
非关系型数据库，没有关系的存在，没有强大的事务来保证数据的完整性和安全性。即：适合处理海量数据，有效率，但不一定安全
适用：
海量数据的存储、对完整性和安全性要求不高的数据

3、关系型数据库与非关系型数据库的结合
思想：
海量数据、不重要的数据可以保存在非关系型数据库中
重要的数据、对完整性和安全性有要求的数据可以保存在关系型数据库中', '2019-05-10 05:19:17.364279');
INSERT INTO "blog_article" VALUES (14, '稀疏矩阵的存储 --数据结构', '1、稀疏矩阵的定义
在一个矩阵中，非零的元素的个数远远多于零元素的个数，并且非零元素的分布没有规律，称为稀疏矩阵。
2、稀疏矩阵的存储
存储稀疏矩阵中非零元素时，必须存储其位置。三元组（i，j，aij）可唯一确定矩阵中的一个元素。稀疏矩阵的三元组表的顺序存储称为三元组顺序表，常用的三元组表的链式存储结构是十字链表。', '1、稀疏矩阵的定义
在一个矩阵中，非零的元素的个数远远多于零元素的个数，并且非零元素的分布没有规律，称为稀疏矩阵。

2、稀疏矩阵的存储
存储稀疏矩阵中非零元素时，必须存储其位置。三元组（i，j，aij）可唯一确定矩阵中的一个元素。稀疏矩阵的三元组表的顺序存储称为三元组顺序表，常用的三元组表的链式存储结构是十字链表。

3、稀疏矩阵中的上三角矩阵与下三角矩阵
主对角线以下都是零的方阵称为上三角矩阵，主对角线以上都是零的方阵称为下三角矩阵。稀疏矩阵大量元素是零，存储一部分内容就已经把有效数据存储了，这可以节省很多空间。存储稀疏矩阵一般存储上三角矩阵或下三角矩阵，如在上三角矩阵或者下三角矩阵中，遇到上半部分和下半部分数据可能重复的情况下，只需要存储上半部分的数据或者下半部分的数据即可。

4、求三角矩阵中某一个元素对应一维数组的下标
稀疏矩阵	计算方法
上三角矩阵	下标分别为i和j的元素对应的一维数组的下标计算公式是：（2 n - i + 1) * i / 2 + j
下三角矩阵	下标分别为i和j的元素对应的一维数组的下标计算公式是：(i + 1) * i / 2 + j
示例：
设有如下所示的下三角矩阵 A [ 0…8 ,0…8 ]，将该三角矩阵的非0元素（即：行下标不小于列下标的所有元素）以行优先压缩存储到 M [ 1…m ]中，则元素 A [ i , j ] (0<=i<8,j<=i)存储在数组M中的( )中？

A(0,0)
A(1,0) A(1,1)
A(2,0) A(2,1) A(2,2)
A(2,0) A(2,1) A(2,2) A(2,3)
. . .
. . .
A(8,0) A(8,1) A(8,2) A(8,3) A(8,4) . . . . . A(8,8)

答案： M [ (i + 1) * i / 2 + j+1 ]

分析：
将A(0,0)即：i=0，j=0代入 (i + 1) * i / 2 + j 中，查看结果是不是M [ 1 ]中的1。很明显，计算结果是0。这里将0加1后的结果才是1，所以我们考虑M中的结果是 (i + 1) * i / 2 + j+1。将A [2,1]中i=2，j=1代入推算的公式： (i + 1) * i / 2 + j+1，发现A[1,2]对应M [5 ]，满足条件。通过代入矩阵中的其它元素后，发现我们推导的公式： (i + 1) * i / 2 + j+1是满足题意的。所以，答案是：M [ (i + 1) * i / 2 + j+1 ]', '2019-05-12 04:49:06.801847');
INSERT INTO "blog_article" VALUES (15, '数组存储地址的计算 --数据结构', '1、数组结构的特点
（1） 数组元素数目不变，一旦定义了一个数组结构，数组元素个数就不会发生改变
（2） 数组元素具有相同的数据类型
（3） 数组元素的下标关系具有上下界的约束且下标有序

2、数组的两个基本运算
（1） 给定一组下标，存取相应的数据元素
（2） 给定一组下标，修改相应的数组元素中某个数据项的值', '1、数组结构的特点
（1） 数组元素数目不变，一旦定义了一个数组结构，数组元素个数就不会发生改变
（2） 数组元素具有相同的数据类型
（3） 数组元素的下标关系具有上下界的约束且下标有序

2、数组的两个基本运算
（1） 给定一组下标，存取相应的数据元素
（2） 给定一组下标，修改相应的数组元素中某个数据项的值

3、数组的存储
根据数组结构的特点知道数组一般不做插入和删除操作，数组的存储适合采用顺序存储结构，二维数组存储结构可分为按行为主序和按列为主序两种存储方法。

4、数组存储地址的计算
数组类型	存储地址的计算（a是数组首地址，len是每个数组元素所占长度）
一维数组	a[i]的存储地址：a+i*len
二维数组：a[m][n]	按行存储：a+(i*n+j) *len；按列存储：a+(j *m+i) *len
5、数组存储地址的计算示例：
1）已知一维数组a中每个元素占用2个字节，求a[10]的存储地址？

答：a[10]的存储地址为：a+10*2=a+20
2）已知4行5列的二维数组a中的每个元素占用2个字节，求元素a[3][2]按行为主序存储的存储地址和按列为主序存储的存储地址？

答：
按行存储：a+(3*5+2)*2 = a+34
按列存储：a+(2*4+3)*2 = a+22', '2019-05-12 04:50:35.521748');
INSERT INTO "blog_article" VALUES (16, 'Python字符串 --Python3', 'Python语言中，字符串是用两个双引号或者单引号括起来的词汇表或多个字符。
1、Python字符串的两种序号体系
反向递减序号：…… -9 -8 -7 -6 -5 -4 -3 -2 -1
正向递增序号：0 1 2 3 4 5 6 7 8 9……', 'Python语言中，字符串是用两个双引号或者单引号括起来的词汇表或多个字符。
1、Python字符串的两种序号体系
反向递减序号：…… -9 -8 -7 -6 -5 -4 -3 -2 -1
正向递增序号：0 1 2 3 4 5 6 7 8 9……
2、获取子串(切片)
可以通过[N:M]格式获取字符串的字串（切片），获取字符串从N到M（不包含M）间连续的子字符串。
print(''Hello Thanlon!''[1])
1
结果如下：
e

print(''Hello Thanlon!''[0:5])
1
结果如下：
Hello

print(''Hello Thanlon!''[-8:-1])
1
结果如下：
Thanlon

3、len函数获取字符串长度
一个中文字符和和西文字符人长度均记为1
print(len(''你好 Thanlon!''))
1
结果如下：

11', '2019-05-12 04:54:27.144540');

-- ----------------------------
-- Auto increment value for blog_article
-- ----------------------------
UPDATE "sqlite_sequence" SET seq = 16 WHERE name = 'blog_article';

PRAGMA foreign_keys = true;
